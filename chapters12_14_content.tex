% Chapters 12-14 Content - Alien Invasion Project
% This file contains the essential keywords and definitions from Chapters 12-14
% covering the complete Alien Invasion game project

This document contains the essential keywords and definitions from Chapters 12-14 of "Python Crash Course" covering the complete Alien Invasion game project, along with their corresponding code examples.

\section*{Project Overview: Alien Invasion Game}
Chapters 12-14 focus on building a complete 2D game using Pygame. The project progresses from basic game setup to a fully functional space shooter with scoring, levels, and user interface elements.

\subsection*{Chapter 12: A Ship that Fires Bullets}

\subsection*{1. Pygame - Game Development Library}
\textbf{Definition}: A set of Python modules designed for writing video games, providing tools for graphics, sound, and input handling.

\begin{lstlisting}
import pygame
pygame.init()
\end{lstlisting}

\subsection*{2. Game Loop - Core Game Logic}
\textbf{Definition}: The main loop that runs continuously during gameplay, handling events, updating game state, and rendering graphics.

\begin{lstlisting}
def run_game(self):
    """Start the main loop for the game."""
    while True:
        # Watch for keyboard and mouse events.
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                sys.exit()
        
        # Update game objects
        self.ship.update()
        
        # Redraw the screen
        self.screen.fill(self.settings.bg_color)
        self.ship.blitme()
        pygame.display.flip()
\end{lstlisting}

\subsection*{3. Surface - Drawing Canvas}
\textbf{Definition}: A Pygame object that represents a rectangular area where you can draw graphics.

\begin{lstlisting}
self.screen = pygame.display.set_mode((1200, 800))
self.screen.fill((230, 230, 230))  # Fill with background color
\end{lstlisting}

\subsection*{4. Rect - Rectangle Object}
\textbf{Definition}: A Pygame object that represents a rectangle, used for positioning and collision detection.

\begin{lstlisting}
self.rect = self.image.get_rect()
self.rect.midbottom = self.screen_rect.midbottom
\end{lstlisting}

\subsection*{5. Sprite - Game Object}
\textbf{Definition}: A 2D object that can be drawn on the screen, typically representing game characters or elements.

\begin{lstlisting}
class Ship:
    """A class to manage the ship."""
    def __init__(self, ai_game):
        self.screen = ai_game.screen
        self.image = pygame.image.load('images/ship.bmp')
        self.rect = self.image.get_rect()
\end{lstlisting}

\subsection*{6. Event Handling - User Input}
\textbf{Definition}: The process of detecting and responding to user actions like key presses and mouse movements.

\begin{lstlisting}
for event in pygame.event.get():
    if event.type == pygame.QUIT:
        sys.exit()
    elif event.type == pygame.KEYDOWN:
        if event.key == pygame.K_RIGHT:
            self.ship.moving_right = True
    elif event.type == pygame.KEYUP:
        if event.key == pygame.K_RIGHT:
            self.ship.moving_right = False
\end{lstlisting}

\subsection*{7. Movement Flags - State Management}
\textbf{Definition}: Boolean variables that track whether an object should be moving in a particular direction.

\begin{lstlisting}
# Movement flags
self.moving_right = False
self.moving_left = False

def update(self):
    """Update the ship's position based on movement flags."""
    if self.moving_right and self.rect.right < self.screen_rect.right:
        self.x += self.settings.ship_speed
    if self.moving_left and self.rect.left > 0:
        self.x -= self.settings.ship_speed
\end{lstlisting}

\subsection*{8. Bullet Class - Projectile System}
\textbf{Definition}: A class that manages bullets fired by the ship, including their movement and collision detection.

\begin{lstlisting}
class Bullet(Sprite):
    """A class to manage bullets fired from the ship."""
    
    def __init__(self, ai_game):
        super().__init__()
        self.screen = ai_game.screen
        self.settings = ai_game.settings
        self.color = self.settings.bullet_color
        
        # Create a bullet rect at (0, 0) and then set correct position.
        self.rect = pygame.Rect(0, 0, self.settings.bullet_width,
            self.settings.bullet_height)
        self.rect.midtop = ai_game.ship.rect.midtop
        
        # Store the bullet's position as a decimal value.
        self.y = float(self.rect.y)
    
    def update(self):
        """Move the bullet up the screen."""
        # Update the decimal position of the bullet.
        self.y -= self.settings.bullet_speed
        # Update the rect position.
        self.rect.y = self.y
    
    def draw_bullet(self):
        """Draw the bullet to the screen."""
        pygame.draw.rect(self.screen, self.color, self.rect)
\end{lstlisting}

\section*{Chapter 13: Aliens}

\subsection*{9. Alien Fleet - Enemy Management}
\textbf{Definition}: A group of alien sprites that move together and represent the enemies in the game.

\begin{lstlisting}
class Alien(Sprite):
    """A class to represent a single alien in the fleet."""
    
    def __init__(self, ai_game):
        super().__init__()
        self.screen = ai_game.screen
        self.settings = ai_game.settings
        
        # Load the alien image and set its rect attribute.
        self.image = pygame.image.load('images/alien.bmp')
        self.rect = self.image.get_rect()
        
        # Start each new alien near the top left of the screen.
        self.rect.x = self.rect.width
        self.rect.y = self.rect.height
        
        # Store the alien's exact horizontal position.
        self.x = float(self.rect.x)
\end{lstlisting}

\subsection*{10. Fleet Movement - Coordinated Motion}
\textbf{Definition}: The synchronized movement of all aliens in the fleet, including direction changes and dropping down.

\begin{lstlisting}
def _check_fleet_edges(self):
    """Respond appropriately if any aliens have reached an edge."""
    for alien in self.aliens.sprites():
        if alien.check_edges():
            self._change_fleet_direction()
            break

def _change_fleet_direction(self):
    """Drop the entire fleet and change the fleet's direction."""
    for alien in self.aliens.sprites():
        alien.rect.y += self.settings.fleet_drop_speed
    self.settings.fleet_direction *= -1
\end{lstlisting}

\subsection*{11. Collision Detection - Hit Testing}
\textbf{Definition}: The process of determining when game objects touch or overlap, used for bullet-alien collisions.

\begin{lstlisting}
def _check_bullet_alien_collisions(self):
    """Respond to bullet-alien collisions."""
    # Remove any bullets and aliens that have collided.
    collisions = pygame.sprite.groupcollide(
        self.bullets, self.aliens, True, True)
    
    if collisions:
        for aliens in collisions.values():
            self.stats.score += self.settings.alien_points * len(aliens)
        self.sb.prep_score()
\end{lstlisting}

\subsection*{12. Sprite Groups - Object Collections}
\textbf{Definition}: Pygame containers that hold multiple sprites, making it easier to update and draw them together.

\begin{lstlisting}
from pygame.sprite import Group

class AlienInvasion:
    def __init__(self):
        # Create groups to store bullets and aliens
        self.bullets = Group()
        self.aliens = Group()
        
        self._create_fleet()
    
    def _create_fleet(self):
        """Create the fleet of aliens."""
        # Create an alien and find the number of aliens in a row.
        alien = Alien(self)
        alien_width, alien_height = alien.rect.size
        
        available_space_x = self.settings.screen_width - (2 * alien_width)
        number_aliens_x = available_space_x // (2 * alien_width)
        
        # Determine the number of rows of aliens that fit on the screen.
        ship_height = self.ship.rect.height
        available_space_y = (self.settings.screen_height -
                            (3 * alien_height) - ship_height)
        number_rows = available_space_y // (2 * alien_height)
        
        # Create the full fleet of aliens.
        for row_number in range(number_rows):
            for alien_number in range(number_aliens_x):
                self._create_alien(alien_number, row_number)
\end{lstlisting}

\subsection*{13. Game Stats - State Tracking}
\textbf{Definition}: A class that tracks game statistics like score, level, and lives remaining.

\begin{lstlisting}
class GameStats:
    """Track statistics for Alien Invasion."""
    
    def __init__(self, ai_game):
        """Initialize statistics."""
        self.settings = ai_game.settings
        self.reset_stats()
        
        # Start game in an inactive state.
        self.game_active = False
        
        # High score should never be reset.
        self.high_score = 0
    
    def reset_stats(self):
        """Initialize statistics that can change during the game."""
        self.ships_left = self.settings.ship_limit
        self.score = 0
        self.level = 1
\end{lstlisting}

\section*{Chapter 14: Scoring}

\subsection*{14. Score Display - UI Elements}
\textbf{Definition}: Visual elements that show the player's current score, high score, and level.

\begin{lstlisting}
class Scoreboard:
    """A class to report scoring information."""
    
    def __init__(self, ai_game):
        """Initialize scorekeeping attributes."""
        self.ai_game = ai_game
        self.screen = ai_game.screen
        self.screen_rect = self.screen.get_rect()
        self.settings = ai_game.settings
        self.stats = ai_game.stats
        
        # Font settings for scoring information.
        self.text_color = (30, 30, 30)
        self.font = pygame.font.SysFont(None, 48)
        
        # Prepare the initial score images.
        self.prep_score()
        self.prep_high_score()
        self.prep_level()
        self.prep_ships()
    
    def prep_score(self):
        """Turn the score into a rendered image."""
        rounded_score = round(self.stats.score, -1)
        score_str = "{:,}".format(rounded_score)
        self.score_image = self.font.render(score_str, True,
                self.text_color, self.settings.bg_color)
        
        # Display the score at the top right of the screen.
        self.score_rect = self.score_image.get_rect()
        self.score_rect.right = self.screen_rect.right - 20
        self.score_rect.top = 20
\end{lstlisting}

\subsection*{15. Play Button - User Interface}
\textbf{Definition}: A clickable button that allows players to start or restart the game.

\begin{lstlisting}
class Button:
    def __init__(self, ai_game, msg):
        """Initialize button attributes."""
        self.screen = ai_game.screen
        self.screen_rect = self.screen.get_rect()
        
        # Set the dimensions and properties of the button.
        self.width, self.height = 200, 50
        self.button_color = (0, 255, 0)
        self.text_color = (255, 255, 255)
        self.font = pygame.font.SysFont(None, 48)
        
        # Build the button's rect object and center it.
        self.rect = pygame.Rect(0, 0, self.width, self.height)
        self.rect.center = self.screen_rect.center
        
        # The button message needs to be prepped only once.
        self._prep_msg(msg)
    
    def _prep_msg(self, msg):
        """Turn msg into a rendered image and center text on the button."""
        self.msg_image = self.font.render(msg, True, self.text_color,
                self.button_color)
        self.msg_image_rect = self.msg_image.get_rect()
        self.msg_image_rect.center = self.rect.center
    
    def draw_button(self):
        """Draw blank button and then draw message."""
        self.screen.fill(self.button_color, self.rect)
        self.screen.blit(self.msg_image, self.msg_image_rect)
\end{lstlisting}

\subsection*{16. Mouse Events - Click Detection}
\textbf{Definition}: Events that occur when the user moves or clicks the mouse, used for button interactions.

\begin{lstlisting}
def _check_play_button(self, mouse_pos):
    """Start a new game when the player clicks Play."""
    button_clicked = self.play_button.rect.collidepoint(mouse_pos)
    if button_clicked and not self.stats.game_active:
        # Reset the game settings.
        self.settings.initialize_dynamic_settings()
        
        # Reset the game statistics.
        self.stats.reset_stats()
        self.stats.game_active = True
        self.sb.prep_score()
        self.sb.prep_level()
        self.sb.prep_ships()
        
        # Get rid of any remaining aliens and bullets.
        self.aliens.empty()
        self.bullets.empty()
        
        # Create a new fleet and center the ship.
        self._create_fleet()
        self.ship.center_ship()
        
        # Hide the mouse cursor.
        pygame.mouse.set_visible(False)
\end{lstlisting}

\subsection*{17. Level Progression - Difficulty Scaling}
\textbf{Definition}: The system that increases game difficulty as the player advances through levels.

\begin{lstlisting}
def _check_aliens_bottom(self):
    """Check if any aliens have reached the bottom of the screen."""
    screen_rect = self.screen.get_rect()
    for alien in self.aliens.sprites():
        if alien.rect.bottom >= screen_rect.bottom:
            # Treat this the same as if the ship got hit.
            self._ship_hit()
            break

def _ship_hit(self):
    """Respond to the ship being hit by an alien."""
    if self.stats.ships_left > 0:
        # Decrement ships_left, and update scoreboard.
        self.stats.ships_left -= 1
        self.sb.prep_ships()
        
        # Get rid of any remaining aliens and bullets.
        self.aliens.empty()
        self.bullets.empty()
        
        # Create a new fleet and center the ship.
        self._create_fleet()
        self.ship.center_ship()
        
        # Pause.
        sleep(0.5)
    else:
        self.stats.game_active = False
        pygame.mouse.set_visible(True)
\end{lstlisting}

\section*{Practical Examples from the Alien Invasion Project}

\subsection*{Complete Game Structure}
The Alien Invasion project demonstrates a complete game development workflow:

\textbf{Main Game File:}
\lstinputlisting[language=Python, caption=Project1/adding\_ship\_image/alien\_invasion.py]{Project1/adding_ship_image/alien_invasion.py}

\textbf{Game Settings:}
\lstinputlisting[language=Python, caption=Project1/adding\_ship\_image/settings.py]{Project1/adding_ship_image/settings.py}

\textbf{Ship Class:}
\lstinputlisting[language=Python, caption=Project1/adding\_ship\_image/ship.py]{Project1/adding_ship_image/ship.py}

\textbf{To run the game:}
\begin{verbatim}
python Project1/adding_ship_image/alien_invasion.py
\end{verbatim}

\section*{Summary}
Chapters 12-14 cover the complete development of a 2D space shooter game using Pygame. The project progresses from basic game setup to a fully functional game with scoring, levels, and user interface elements.

\section*{Key Takeaways}
\begin{itemize}
    \item Pygame provides tools for 2D game development
    \item Game loops handle events, updates, and rendering
    \item Sprites represent game objects with position and graphics
    \item Event handling captures user input
    \item Collision detection determines object interactions
    \item Sprite groups manage collections of game objects
    \item Game stats track score, lives, and level
    \item UI elements like buttons enhance user experience
    \item Mouse events enable interactive elements
    \item Level progression increases game difficulty
    \item Proper game state management is crucial
    \item Code organization improves maintainability
    \item Real-time graphics require efficient rendering
    \item User feedback through scoring and visual elements
\end{itemize}

\section*{Project Progression}
\begin{enumerate}
    \item \textbf{Chapter 12}: Basic game setup, ship movement, and bullet firing
    \item \textbf{Chapter 13}: Alien fleet creation, movement, and collision detection
    \item \textbf{Chapter 14}: Scoring system, UI elements, and game completion
\end{enumerate}

This three-chapter project demonstrates complete game development from concept to finished product, covering all essential aspects of 2D game programming with Python and Pygame. 